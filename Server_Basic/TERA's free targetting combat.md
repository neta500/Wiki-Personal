ref : http://bowling-bash.blogspot.com/2012/06/teras-free-targetting-combat-server.html

04 JUNE 2012

GD mag May 2012 issue에서, TERA의 서버 아키텍처인 구승모 씨는, 논타겟팅 전투 시스템을 서버 백엔드에서  
어떻게 구현했는지를 발표했다. 기고에 실린 기술적인 솔루션 중 몇몇 부분이 불명확하거나, 문제가 명백하지
않아, 그 갭을 메우기 위해 이 글을 썼다.

## Basics  

전투를 하는 동안, 플레이어는 다양한 종류의 공격과 스킬을 사용한다. 플레이어에게, 논타겟팅이란 아바타의 
방향과 위치에 주의를 기울인다는 것을 의미한다. WoW와 같은 몬스터 선택은 없다.  
실제 게임 장면을 보면, 전투가 더 생동감있게 느껴지지만, 많은 hit and run이 있다. 

시스템적인 관점에서 보면, 논타겟팅은 유저가 어떤 몬스터를 타겟팅하고있는지 서버가 모른다.  
그러므로 서버는 스킬의 범위와 충돌체크를 통해 어떤 몬스터가 스킬을 맞았는지 알아내야 한다.  
충돌에 대한 빠른 계산을 위해, 서버는 60fps(1초에 60번 Update 루프)로 실행된다. 이것은 보안과 단순함 및 클라이언트의 
렉 보정을 제외하면 일반적인 멀티플레이어 FPS 게임이 요구하는 기능과 같다. 모든 계산은 서버에서 수행된다.  
하지만, MMORPG가 FPS와 같이 반응성이 뛰어난 게임 플레이를 제공하려면, 클라이언트는 플레이어의 동작을
즉시 수행하고, 렉에 대한 처리를 하고, 결국엔 몇몇 NPC도 돌려야한다.  
TERA에서 MMO에서의 렉에 대한 설명은, PVE에서 NPC가 플레이어에게 반응할 시간을 주기에는 느리고,
PVP에서는 서버에 대한 ping이 낮은 플레이어가 유리하다는 것이다.  

![](http://i.imgur.com/XMy61.jpg)

## Game design  

게임 세계에서의 모든 크리처는 실린더(cylinders)로 만들어져있다. 스킬 충돌체가 타겟의 실린더에 닿았을 때
충돌이 일어난다. 스킬 효과의 부피는 실린더가 될 수도 있고(ex) 타겟대상이나 자기자신을 둘러싼 범위공격),  
실린더의 일부가 될 수도 있고(ex) 도끼를 휘두르는 공격), 원뿔의 일부가 될 수도 있다(ex) 창으로 찌르는 공격).  

스킬은 일정 시간 지속될 수 있기 때문에, 여러번에 나눠서 적중될 수 있고, 각 적중 시간은 스킬 효과의  
충돌체의 크기와 상관이 있다. 각 적중 시간은 두 페이즈로 구성되어 있다. search 페이즈, update 페이즈.  
예를 들면, 회전 공격을 사용할 때, 공격자는 300ms 동안 360도를 회전하며, 회전하는 동안 데미지를 준다.  
첫번째 적중 시간은 search 페이즈인 50ms이다. 0-50ms 동안 서버는 스킬의 적중 범웨 내에 있는 물체를 검색한다.  
50-100ms 에는 200 데미지를 준다. (update 페이즈). 동일하게 100-200ms에도 적중 대상을 검색하고, 100 데미지를 준다.  
200-300ms에는 적중 대상을 검색하고, 50 데미지를 준다.  

![](http://i.imgur.com/vgnQc.png)  

## Multi-threading and performance  

각 TERA 서버는 월드의 약 6000명의 동시 접속자 수를 처리한다. 서버는 메인 루프에서 몇 가지 처리할 일이 있다.
클라이언트 패킷 프로세싱, 타이머 작동, 지역 생성, 몬스터 작업 등을 처리한다. 이곳에서 타겟을 검색하는 페이즈가 수행된다.  
그리고, 지역을 생성하거나 몬스터 태스크를 처리하는 작업을 수행한다. update 페이즈(ex) 데미지 처리)는  
몬스터 태스크에서 발생하고, 몬스터의 이동, 스폰, 죽음 이벤트의 경우 지역 태스크에서도 발생한다.  
위의 논타겟팅 예와 같이, 막대한 처리량을 요구한다.  

최종 설계를 하기 위해, TERA 엔지니어들은 다음과 같은 일련의 생각들을 했을 것이다.

- 문제 : 8-Core 윈도우 서버가 3000명을 받았을 때 cpu 100%를 찍는다. 어떻게 개선할까?  

- 해결 : IOCP가 제공하는 비동기, 멀티스레드로 유저 작업을 처리한다.  

- 새로운 문제 : 멀티스레드를 쓰니까 물귀신처럼 따라오는게 공유 자원에 대한 동기화 문제이다.  
lock을 거니까 스레드가 lock을 획득하기 위해 기다리는 시간이 많아진다. ( 지역, 크리처에 대한 처리를 하기 위해 lock을  
얻어야 하는데 오래걸린다.)  

- 해결 : 각 스레드 별로 월드의 복제본을 지니게 하고, 자기 작업은 자기 월드에 업데이트한다. ( lock을 없앰 )  

- 새로운 문제 : 스레드 별로 자기 월드만 업데이트하니까 스레드마다 월드 데이터가 다르다.  

- 해결 : 테라는 논타겟이어서 맵(지역)을 읽어야하는 작업이 엄청나게 많은데, Read는 자기 ThreadLocal에서 바로 읽고, 
Update는 region update queue에 던져서 비동기로 처리한다. 비동기로 처리하기 때문에 어떤 한 순간에서는 특정 스레드가 
과거의 데이터를 읽을 수도 있다. 이말은 논타겟팅 스킬을 딱 썼는데 어떤 타겟이 부분적으로 걸리지 않을 수도 있다는 것이다.
근데 이건 논타겟 스킬로 많은 수의 몬스터를 때리다보면 플레이어는 데미지플로터가 엄청 뜨는데 한개정도는 안떠도 
모른다. 이렇게 눈속임으로 커버를 치는 것이다.
만약 1번 스레드에서 Update가 발생하면 1번 스레드는 region update queue에 Update 내용을 기록한다. 그리고 스레드 별로
각자 알아서 queue에서 Update 내용을 가져가서 자기 월드에 Update를 한다. 
스레드가 8개라면 region queue에 카운터가 8인 작업을 넣고, 각 스레드가 작업을 처리할 때마다 카운터를 감소시킨다. 카운터가 0이되면 모든 스레드가 자신의 월드에 작업을 업데이트 한 것이므로, queue에서 작업을 삭제한다. (마지막에 업데이트한 스레드가 삭제함.)

- 새로운 update 페이즈 문제 : 특정 크리처를 자주 업데이트하는 것이 lock 경합을 발생시킨다.  
(당연하지만 크리처는 월드 복제본마다 돌릴 수가 없음)  

- 해결 : 각 스레드의 월드 복제본은 크리처 포인터들을 저장하고 있는다. 각 크리처마다 task queue를 만들어 queue에  
들어오는 작업을 처리한다. 스레드가 패킷이나 타이머로 인한 크리처 업데이트를 해야할 경우, 각 크리처의 task queue에  
작업을 집어넣는다. (ex) Creature.receiveDamage, arg : 200). 만약 어떤 스레드가 크리처의 task queue를 돌리고 있는데  
다른 스레드가 해당 크리처에 대한 추가적인 task를 처리해야하면, 그냥 task queue에 집어던지고 자기 할 일을 한다.  
task queue를 돌리고 있던 스레드가 추가 task까지 처리한다(queue가 empty일 때 까지). 그러므로, 크리처 task는  
비동기로 처리되고, task 실행 결과를 얻으려면 active object pattern을 사용해야 한다.  

설계 결과는 다음과 같다:  
![](http://i.imgur.com/7FAhG.png)





